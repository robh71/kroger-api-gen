# coding: utf-8

"""
    Kroger API Reference

    <br> <div style=\"background-color: #ffebb2; padding: 16px; border-radius: .25rem; border: 1px solid #ff8d00; padding: 8px; font-size: 13.5px; padding-right: 12px; padding-left: 12px; padding-top: 14px; padding-bottom: 14px;\"><b>DEPRECATION NOTICE</b> - As of 06/01/2020, the Coupons API is no longer available. Currently, there is no direct replacement for the Coupons API.</div>  # Introduction The following APIs are publicly available to allow new clients to build products,  services, or customer experiences that leverage the unique data, functions, and  applications of Kroger. As a company that strives to empower the developer community  and meet our customers where they are, we are offering these APIs as the first  step to building an ecosystem that promotes speed, simplicity, and security. <br><br> To begin using our Public APIs, see the [Getting Started](https://developer.kroger.com/documentation/consume) documentation.   # Environments  During registration, we require apps to be registered for environments individually. Use one of the following paths based on the environment you selected for your application during the registration process.  | Environment | Path | |-------------|------| |Production | https://api.kroger.com/v1/ | |Certification | https://api-ce.kroger.com/v1/ |  # Authentication  For API authentication, Kroger uses the OAuth2 protocol ([RFC6749](https://tools.ietf.org/html/rfc6749)),  supporting the Authorization Code, Client Credentials, and Refresh Token grant types. If you're unfamiliar  with OAuth2, see our [Understanding OAuth2](https://developer.kroger.com/documentation/consume/guides/understanding-oauth2)  documentation.   <!-- ReDoc-Inject: <security-definitions> -->   # noqa: E501

    OpenAPI spec version: 1.2.1
    Contact: APISupport@kroger.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class LocationsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def chain_exists(self, name, **kwargs):  # noqa: E501
        """Chain query  # noqa: E501

        Determine if a specific chain exists by using the chain `name`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chain_exists(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of a chain owned by The Kroger Co. <br><br> **Note**: the chain `name` is returned from the [/chains](/#operation/ListChains) endpoint as `name` and from the [/locations](/#operation/SearchLocations) endpoint as `chain`. (required)
        :return: APIErrorNoContent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chain_exists_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.chain_exists_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def chain_exists_with_http_info(self, name, **kwargs):  # noqa: E501
        """Chain query  # noqa: E501

        Determine if a specific chain exists by using the chain `name`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chain_exists_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of a chain owned by The Kroger Co. <br><br> **Note**: the chain `name` is returned from the [/chains](/#operation/ListChains) endpoint as `name` and from the [/locations](/#operation/SearchLocations) endpoint as `chain`. (required)
        :return: APIErrorNoContent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chain_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `chain_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context']  # noqa: E501

        return self.api_client.call_api(
            '/chains/{name}', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIErrorNoContent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def department_exists(self, id, **kwargs):  # noqa: E501
        """Department query  # noqa: E501

        Determine if a specific department exists by using the `departmentId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.department_exists(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The departmentId of the department to return. (required)
        :return: APIErrorNoContent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.department_exists_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.department_exists_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def department_exists_with_http_info(self, id, **kwargs):  # noqa: E501
        """Department query  # noqa: E501

        Determine if a specific department exists by using the `departmentId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.department_exists_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The departmentId of the department to return. (required)
        :return: APIErrorNoContent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method department_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `department_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context']  # noqa: E501

        return self.api_client.call_api(
            '/departments/{id}', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIErrorNoContent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_chain(self, name, **kwargs):  # noqa: E501
        """Chain details  # noqa: E501

        Provides access to the details of a specific chian by using the chain `name`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_chain(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of a chain owned by The Kroger Co. <br><br> **Note**: the chain `name` is returned from the [/chains](/#operation/ListChains) endpoint as `name` and from the [/locations](/#operation/SearchLocations) endpoint as `chain`. (required)
        :return: LocationsChainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_chain_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_chain_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_chain_with_http_info(self, name, **kwargs):  # noqa: E501
        """Chain details  # noqa: E501

        Provides access to the details of a specific chian by using the chain `name`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_chain_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of a chain owned by The Kroger Co. <br><br> **Note**: the chain `name` is returned from the [/chains](/#operation/ListChains) endpoint as `name` and from the [/locations](/#operation/SearchLocations) endpoint as `chain`. (required)
        :return: LocationsChainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_chain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_chain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context']  # noqa: E501

        return self.api_client.call_api(
            '/chains/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LocationsChainResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_department(self, id, **kwargs):  # noqa: E501
        """Department details  # noqa: E501

        Provides access to the details of a specific department by using the `departmentId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_department(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The departmentId of the department to return. (required)
        :return: LocationsDepartmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_department_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_department_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_department_with_http_info(self, id, **kwargs):  # noqa: E501
        """Department details  # noqa: E501

        Provides access to the details of a specific department by using the `departmentId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_department_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The departmentId of the department to return. (required)
        :return: LocationsDepartmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_department" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_department`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context']  # noqa: E501

        return self.api_client.call_api(
            '/departments/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LocationsDepartmentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_chains(self, **kwargs):  # noqa: E501
        """Chain list  # noqa: E501

        Provides access to a list of all chains owned by The Kroger Co.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_chains(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LocationsChainsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_chains_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_chains_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_chains_with_http_info(self, **kwargs):  # noqa: E501
        """Chain list  # noqa: E501

        Provides access to a list of all chains owned by The Kroger Co.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_chains_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LocationsChainsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_chains" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context']  # noqa: E501

        return self.api_client.call_api(
            '/chains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LocationsChainsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_departments(self, **kwargs):  # noqa: E501
        """Department list  # noqa: E501

        Provides access to a list of all departments, including departments of chains owned by The Kroger Co.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_departments(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LocationsDepartmentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_departments_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_departments_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_departments_with_http_info(self, **kwargs):  # noqa: E501
        """Department list  # noqa: E501

        Provides access to a list of all departments, including departments of chains owned by The Kroger Co.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_departments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LocationsDepartmentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_departments" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context']  # noqa: E501

        return self.api_client.call_api(
            '/departments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LocationsDepartmentsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def locations_exists_by_id(self, location_id, **kwargs):  # noqa: E501
        """Location query  # noqa: E501

        Determines if a specific location exists by using the `locationId`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.locations_exists_by_id(location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: The locationId of the store. (required)
        :return: APIErrorNoContent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.locations_exists_by_id_with_http_info(location_id, **kwargs)  # noqa: E501
        else:
            (data) = self.locations_exists_by_id_with_http_info(location_id, **kwargs)  # noqa: E501
            return data

    def locations_exists_by_id_with_http_info(self, location_id, **kwargs):  # noqa: E501
        """Location query  # noqa: E501

        Determines if a specific location exists by using the `locationId`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.locations_exists_by_id_with_http_info(location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: The locationId of the store. (required)
        :return: APIErrorNoContent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['location_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method locations_exists_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'location_id' is set
        if ('location_id' not in params or
                params['location_id'] is None):
            raise ValueError("Missing the required parameter `location_id` when calling `locations_exists_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'location_id' in params:
            path_params['locationId'] = params['location_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context']  # noqa: E501

        return self.api_client.call_api(
            '/locations/{locationId}', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIErrorNoContent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def locations_get_by_id(self, location_id, **kwargs):  # noqa: E501
        """Location details  # noqa: E501

        Provides access to the details of a specific location by using the `locationId`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.locations_get_by_id(location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: The locationId of the store. (required)
        :return: LocationsLocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.locations_get_by_id_with_http_info(location_id, **kwargs)  # noqa: E501
        else:
            (data) = self.locations_get_by_id_with_http_info(location_id, **kwargs)  # noqa: E501
            return data

    def locations_get_by_id_with_http_info(self, location_id, **kwargs):  # noqa: E501
        """Location details  # noqa: E501

        Provides access to the details of a specific location by using the `locationId`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.locations_get_by_id_with_http_info(location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: The locationId of the store. (required)
        :return: LocationsLocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['location_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method locations_get_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'location_id' is set
        if ('location_id' not in params or
                params['location_id'] is None):
            raise ValueError("Missing the required parameter `location_id` when calling `locations_get_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'location_id' in params:
            path_params['locationId'] = params['location_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context']  # noqa: E501

        return self.api_client.call_api(
            '/locations/{locationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LocationsLocationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_locations(self, **kwargs):  # noqa: E501
        """Location list  # noqa: E501

        Provides access to a list of locations matching a given criteria. If the parameter `filter.chain` is not provided, the results include all locations and chains owned by The Kroger Co.<br> <h3>Starting Point Required</h3> You must include one of the following parameters as a starting point to narrow search results:<br><br> <ul> <li> <code>filter.zipCode.near</code></li> <li> <code>filter.latLong.near</code></li> <li> <code>filter.lat.near</code> and <code>filter.lon.near</code></li> </ul><br> If you do not provide a starting point or provide more than one starting point, an error is returned. By default, the results are limited to 10 locations within a 10-mile radius of the provided starting point. If you would like to extend the search results, you can use the parameter `filter.radiusInMiles` to set a new mile radius or `filter.limit` to set the number of results returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_locations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_zip_code_near: The zip code to use as a starting point for results.
        :param str filter_lat_long_near: The latitude and longitude to use as a starting point for results.
        :param str filter_lat_near: The latitude to use as a starting point for results.
        :param str filter_lon_near: The longitude to use as a starting point for results.
        :param int filter_radius_in_miles: The mile radius of results.
        :param int filter_limit: The number of results to return.
        :param str filter_chain: The chain name of the chain. When using this filter, only stores matching the provided chain name are returned.
        :param str filter_department: The departmentId of the department. Lists must be comma-separated. When using this filter, only stores that have all of the departments provided are returned.
        :return: LocationsLocationSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_locations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_locations_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_locations_with_http_info(self, **kwargs):  # noqa: E501
        """Location list  # noqa: E501

        Provides access to a list of locations matching a given criteria. If the parameter `filter.chain` is not provided, the results include all locations and chains owned by The Kroger Co.<br> <h3>Starting Point Required</h3> You must include one of the following parameters as a starting point to narrow search results:<br><br> <ul> <li> <code>filter.zipCode.near</code></li> <li> <code>filter.latLong.near</code></li> <li> <code>filter.lat.near</code> and <code>filter.lon.near</code></li> </ul><br> If you do not provide a starting point or provide more than one starting point, an error is returned. By default, the results are limited to 10 locations within a 10-mile radius of the provided starting point. If you would like to extend the search results, you can use the parameter `filter.radiusInMiles` to set a new mile radius or `filter.limit` to set the number of results returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_locations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_zip_code_near: The zip code to use as a starting point for results.
        :param str filter_lat_long_near: The latitude and longitude to use as a starting point for results.
        :param str filter_lat_near: The latitude to use as a starting point for results.
        :param str filter_lon_near: The longitude to use as a starting point for results.
        :param int filter_radius_in_miles: The mile radius of results.
        :param int filter_limit: The number of results to return.
        :param str filter_chain: The chain name of the chain. When using this filter, only stores matching the provided chain name are returned.
        :param str filter_department: The departmentId of the department. Lists must be comma-separated. When using this filter, only stores that have all of the departments provided are returned.
        :return: LocationsLocationSearchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_zip_code_near', 'filter_lat_long_near', 'filter_lat_near', 'filter_lon_near', 'filter_radius_in_miles', 'filter_limit', 'filter_chain', 'filter_department']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_locations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_zip_code_near' in params:
            query_params.append(('filter.zipCode.near', params['filter_zip_code_near']))  # noqa: E501
        if 'filter_lat_long_near' in params:
            query_params.append(('filter.latLong.near', params['filter_lat_long_near']))  # noqa: E501
        if 'filter_lat_near' in params:
            query_params.append(('filter.lat.near', params['filter_lat_near']))  # noqa: E501
        if 'filter_lon_near' in params:
            query_params.append(('filter.lon.near', params['filter_lon_near']))  # noqa: E501
        if 'filter_radius_in_miles' in params:
            query_params.append(('filter.radiusInMiles', params['filter_radius_in_miles']))  # noqa: E501
        if 'filter_limit' in params:
            query_params.append(('filter.limit', params['filter_limit']))  # noqa: E501
        if 'filter_chain' in params:
            query_params.append(('filter.chain', params['filter_chain']))  # noqa: E501
        if 'filter_department' in params:
            query_params.append(('filter.department', params['filter_department']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context']  # noqa: E501

        return self.api_client.call_api(
            '/locations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LocationsLocationSearchResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
