# coding: utf-8

"""
    Kroger API Reference

    <br> <div style=\"background-color: #ffebb2; padding: 16px; border-radius: .25rem; border: 1px solid #ff8d00; padding: 8px; font-size: 13.5px; padding-right: 12px; padding-left: 12px; padding-top: 14px; padding-bottom: 14px;\"><b>DEPRECATION NOTICE</b> - As of 06/01/2020, the Coupons API is no longer available. Currently, there is no direct replacement for the Coupons API.</div>  # Introduction The following APIs are publicly available to allow new clients to build products,  services, or customer experiences that leverage the unique data, functions, and  applications of Kroger. As a company that strives to empower the developer community  and meet our customers where they are, we are offering these APIs as the first  step to building an ecosystem that promotes speed, simplicity, and security. <br><br> To begin using our Public APIs, see the [Getting Started](https://developer.kroger.com/documentation/consume) documentation.   # Environments  During registration, we require apps to be registered for environments individually. Use one of the following paths based on the environment you selected for your application during the registration process.  | Environment | Path | |-------------|------| |Production | https://api.kroger.com/v1/ | |Certification | https://api-ce.kroger.com/v1/ |  # Authentication  For API authentication, Kroger uses the OAuth2 protocol ([RFC6749](https://tools.ietf.org/html/rfc6749)),  supporting the Authorization Code, Client Credentials, and Refresh Token grant types. If you're unfamiliar  with OAuth2, see our [Understanding OAuth2](https://developer.kroger.com/documentation/consume/guides/understanding-oauth2)  documentation.   <!-- ReDoc-Inject: <security-definitions> -->   # noqa: E501

    OpenAPI spec version: 1.2.1
    Contact: APISupport@kroger.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ProductsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def product_get(self, **kwargs):  # noqa: E501
        """Product search  # noqa: E501

        Allows you to find products by passing in either a search term or product Id.  ### Initial Search Value Required  An initial search value is requred for all requests. You can use either of the following parameters as an initial search value:   `filter.term` - When using the term parameter, the API performs a fuzzy search based on the term provided in the string. Search results are based on how relevant the term is to the product description.  `filter.productId` - When using the productId parameter, the API performs a query to find an exact match.     # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_term: A search term to filter product results. As an example, you could input _milk_, _bread_, or _salt_.
        :param str filter_location_id: The locationId of the store. When using this filter, only products available at that location are returned.
        :param str filter_product_id: The productId of the products(s) to return. For more than one item, the list must be comma-separated. When used, all other query parameters are ignored.
        :param str filter_brand: The brand name of the products to return. When using this filter, only products by that brand are returned. Brand names are case-sensitive, and lists must be pipe-separated.
        :param str filter_fulfillment: The available fulfillment types of the product(s) to return. Fulfillment types are case-sensitive, and lists must be comma-separated. Must be one or more of the follow types: <ul> <li> `ais` - Available In Store</li> <li> `csp` - Curbside Pickup</li> <li> `dth` - Delivery To Home</li> <li> `sth` - Ship To Home</li> </ui>
        :param int filter_start: The number of products to skip.
        :param int filter_limit: The number of products to return.
        :return: ProductsProductsPayloadModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.product_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.product_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def product_get_with_http_info(self, **kwargs):  # noqa: E501
        """Product search  # noqa: E501

        Allows you to find products by passing in either a search term or product Id.  ### Initial Search Value Required  An initial search value is requred for all requests. You can use either of the following parameters as an initial search value:   `filter.term` - When using the term parameter, the API performs a fuzzy search based on the term provided in the string. Search results are based on how relevant the term is to the product description.  `filter.productId` - When using the productId parameter, the API performs a query to find an exact match.     # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_term: A search term to filter product results. As an example, you could input _milk_, _bread_, or _salt_.
        :param str filter_location_id: The locationId of the store. When using this filter, only products available at that location are returned.
        :param str filter_product_id: The productId of the products(s) to return. For more than one item, the list must be comma-separated. When used, all other query parameters are ignored.
        :param str filter_brand: The brand name of the products to return. When using this filter, only products by that brand are returned. Brand names are case-sensitive, and lists must be pipe-separated.
        :param str filter_fulfillment: The available fulfillment types of the product(s) to return. Fulfillment types are case-sensitive, and lists must be comma-separated. Must be one or more of the follow types: <ul> <li> `ais` - Available In Store</li> <li> `csp` - Curbside Pickup</li> <li> `dth` - Delivery To Home</li> <li> `sth` - Ship To Home</li> </ui>
        :param int filter_start: The number of products to skip.
        :param int filter_limit: The number of products to return.
        :return: ProductsProductsPayloadModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_term', 'filter_location_id', 'filter_product_id', 'filter_brand', 'filter_fulfillment', 'filter_start', 'filter_limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method product_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_term' in params:
            query_params.append(('filter.term', params['filter_term']))  # noqa: E501
        if 'filter_location_id' in params:
            query_params.append(('filter.locationId', params['filter_location_id']))  # noqa: E501
        if 'filter_product_id' in params:
            query_params.append(('filter.productId', params['filter_product_id']))  # noqa: E501
        if 'filter_brand' in params:
            query_params.append(('filter.brand', params['filter_brand']))  # noqa: E501
        if 'filter_fulfillment' in params:
            query_params.append(('filter.fulfillment', params['filter_fulfillment']))  # noqa: E501
        if 'filter_start' in params:
            query_params.append(('filter.start', params['filter_start']))  # noqa: E501
        if 'filter_limit' in params:
            query_params.append(('filter.limit', params['filter_limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context', 'Customer Context']  # noqa: E501

        return self.api_client.call_api(
            '/products', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProductsProductsPayloadModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def product_get_id(self, id, **kwargs):  # noqa: E501
        """Product details  # noqa: E501

        Provides access to the details of a specific product by either using the `productId` or `UPC`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product_get_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Id id: (required)
        :param str filter_location_id: The locationId of the store. When using this filter, only products available at that location are returned.
        :return: ProductsProductPayloadModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.product_get_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.product_get_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def product_get_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Product details  # noqa: E501

        Provides access to the details of a specific product by either using the `productId` or `UPC`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product_get_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Id id: (required)
        :param str filter_location_id: The locationId of the store. When using this filter, only products available at that location are returned.
        :return: ProductsProductPayloadModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'filter_location_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method product_get_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `product_get_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'filter_location_id' in params:
            query_params.append(('filter.locationId', params['filter_location_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Client Context', 'Customer Context']  # noqa: E501

        return self.api_client.call_api(
            '/products/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProductsProductPayloadModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
